| TYPE DISCIPLINE         | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|-------------------------+---------+--------+----------+---------+------+--------+-------|
| strongly typed          | yes     | yes    | yes      | yes     | yes  | yes    | yes   |
| statically typed        | no      | no     | yes      | yes     | yes  | no     | yes   |
| coercion                |         |        |          | no      | yes  | yes    | yes   |
| user-defined conversion |         |        |          |         | no   |        | yes   |


| STATIC TYPING            | F#/OCaml | Haskell | Java | Scala |
|--------------------------+----------+---------+------+-------|
| type inference           | yes      | yes     | no   | yes   |
| function type parameters |          | yes     | yes  | yes   |
| class type parameters    |          |         | yes  | yes   |
| type parameters reified  |          |         | no   | no    |
| existential types        |          |         | yes  | yes   |
| abstract types           |          |         | no   | yes   |
| type bounds              |          |         | yes  | yes   |
| self types               |          |         | no   | yes   |
| path-dependent types     |          |         |      | yes   |
| bottom types             |          |         | no   | yes   |
| compound types           |          |         |      | yes   |
| higher kinded types      |          |         | no   | yes   |
| structural types         |          |         | no   | yes   |
| views                    |          |         |      | yes   |
| sum types                |          |         |      |       |
| product types            |          |         |      |       |
| recursive types          |          |         |      |       |

Notes: Manifests can prevent type-erasure in Scala in only very limited cases.


| OBJECTS                                                        | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|----------------------------------------------------------------+---------+--------+----------+---------+------+--------+-------|
| objects (function/data containers that are first-class values) |         |        | yes      |         | yes  | yes    | yes   |
| all values are objects                                         |         |        |          |         | no   | yes    | yes   |
| interfaces (contracts) with abstract functions                 |         |        |          |         | yes  | no     | yes   |
| interfaces (contracts) with abstract data                      |         |        |          |         | no   | no     | yes   |
| interface inheritance                                          |         |        |          |         | yes  | yes    | yes   |
| concrete inheritance                                           |         |        |          |         | yes  | yes    | yes   |
| multiple interface inheritance                                 |         |        |          |         | yes  | n/a    | yes   |
| multiple concrete inheritance                                  |         |        |          |         | no   | yes    | yes   |
| anonymous classes                                              |         |        |          |         | yes  |        | yes   |
| data hiding enforced                                           |         |        |          |         | yes  | no     | yes   |


| FUNCTIONS                         | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|-----------------------------------+---------+--------+----------+---------+------+--------+-------|
| operators evaluate like functions |         | no     |          |         | no   |        | yes   |
| operator overloading              |         |        |          | yes     | no   | yes    | yes   |
| first-class functions             | yes     | yes    |          | yes     | no   | yes    | yes   |
| anonymous functions               | yes     | yes    |          | yes     | no   | yes    | yes   |
| nested named functions            |         |        |          |         | no   | yes    | yes   |
| currying                          |         |        |          | yes     | no   |        | yes   |
| partial application of functions  |         |        |          | yes     | no   | stdlib | yes   |
| full tail call optimization       | no      | yes    |          | yes     | no   | no     | no    |
| overloading                       | yes     |        |          |         | yes  | no     | yes   |
| default arguments                 |         |        |          |         | no   | yes    | yes   |
| named arguments                   |         |        |          |         | no   | yes    | yes   |
| variable number arguments         |         |        |          |         | yes  |        | yes   |
| unstructured side-effects         | yes     | yes    |          | no      | yes  | yes    | yes   |
| generators                        |         |        |          |         |      |        |       |
| continuations                     |         |        |          |         |      |        |       |

Notes: Scala's methods aren't themselves first-class but can always be treated as such. 


| BINDINGS & SCOPE  | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|-------------------+---------+--------+----------+---------+------+--------+-------|
| lexical scope     |         |        |          |         | yes  | no     | yes   |
| single assignment | no      | yes    |          | yes     | both | no     | both  |
| closures          |         |        |          |         | no   |        | yes   |


| LIBRARY             | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|---------------------+---------+--------+----------+---------+------+--------+-------|
| implicit functions  |         |        |          |         | no   |        | yes   |
| implicit parameters |         |        |          |         | no   |        | yes   |
| first-class modules |         |        |          |         |      | yes    |       |

Notes: Scala 2.8's package objects can only add members to a package.


| EVALUATION                            | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|---------------------------------------+---------+--------+----------+---------+------+--------+-------|
| lazy evaluation                       |         |        |          | yes     | no   | no     | no    |
| lazy initialization of fields         |         |        |          |         | no   |        | yes   |
| delayed parameter evaluation possible |         |        |          |         | no   |        | yes   |
| uniform access principle              |         |        |          |         | no   | no     | yes   |

Notes: Only Java's static fields are initialized lazily.


| LANGUAGE                       | Clojure | Erlang | F#/OCaml | Haskell | Java | Python | Scala |
|--------------------------------+---------+--------+----------+---------+------+--------+-------|
| preprocessor                   | yes     |        |          |         | no   |        | no    |
| pattern matching               | yes     | yes    |          | yes     | no   | no     | yes   |
| pattern matching in parameters |         | yes    |          | yes     | no   | no     | no    |
| reflection                     |         |        |          |         | yes  |        |       |
| metaprogramming                |         |        |          |         |      |        |       |

| CONCURRENCY             | Clojure | Erlang | Haskell | F#/OCaml | Java | Python | Scala |
|-------------------------+---------+--------+---------+----------+------+--------+-------|
| true parallelism        | yes     | yes    | yes     | yes      | yes  | no     | yes   |
| unmanaged mutable state | no      |        | no      |          | yes  | yes    | yes   |

Notes: I'm only considering CPython, whose global interpreter lock prevents two threads from making progress at the same time.
Jython and IronPython do not suffer from this problem.

